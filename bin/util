#!/bin/sh

# Given an input, interprets each argument as a part of a path to a script
# located at $SU_SCRIPTS_PATH

# https://google.github.io/styleguide/shellguide.html

err() {
  printf "$@" >&2
  exit 1
}

scripts_path() {
  local path="${SU_SCRIPTS_PATH:-}"
  [ -z "$path" ] && {
    err "\$SU_SCRIPTS_PATH not defined."
  }
  echo "$path"
}

check_dependencies() {
  command -v find >/dev/null || {
    err "find is necessary for util to work. Please install it before using this executable.\n"
  }
}

check_empty_arguments() {
  local arguments="$@"
  [ -z "$arguments" ] && {
    printf "util is an attempt to be a shell-agnostic custom utilities tool.
It can find and execute your custom scripts like a CLI.
\ne.g. \"\$ util folder script\" will look for a script at \$SU_SCRIPTS_PATH/folder/script.(*)
More at https://github.com/vncsmyrnk/shell-utils\n"
    exit 0
  }
}

find_and_execute_script() {
  IFS=' ' read -r -a argument_list <<< "$@"

  local current_path=$(scripts_path)
  for section in "${argument_list[@]}"; do
    [ -n "$found_script_file_glob" ] && {
      found_script_arguments="$found_script_arguments $section"
    }

    local current_path="$current_path/$section"
    local script_file_glob="$current_path.*"
    [ -x $script_file_glob ] && {
      found_script_file_glob="$script_file_glob"
    }
  done

  if [ -z "$found_script_file_glob" ]; then
    printf "Util file not found. Check \033[1m$(scripts_path)\033[0m for commands available.\n"
    printf "\033[2mTip: pass file without the extension and make it sure it is executable.\033[0m\n"
    exit 1
  fi

  local script_path=$(find $found_script_file_glob)
  if [ $(echo $script_path | wc -l) -gt 1 ]; then
    printf "Ambiguity detected. Make sure the scripts at $(scripts_path) have no name conflict.\n"
    exit 1
  fi

  $script_path $found_script_arguments
}

main() {
  check_dependencies

  arguments="$@"
  check_empty_arguments "$arguments"
  find_and_execute_script "$arguments"
}


main "$@"
