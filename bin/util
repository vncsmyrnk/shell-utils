#!/bin/sh

# Given an input, interprets each argument as a part of a path to a script
# located at $SU_SCRIPTS_PATH

# https://google.github.io/styleguide/shellguide.html

err() {
  printf "%s" "$@" >&2
  exit 1
}

scripts_path() {
  path="${SU_SCRIPTS_PATH:-}"
  [ -z "$path" ] && {
    err "\$SU_SCRIPTS_PATH not defined."
  }
  echo "$path"
}

check_dependencies() {
  command -v find >/dev/null || {
    err "find is necessary for util to work. Please install it before using this executable.\n"
  }
}

check_empty_arguments() {
  [ $# -eq 0 ] && {
    printf "util is a shell-agnostic utility tool designed to make your scripts accessible everywhere using the util command.
It can find and execute your custom scripts like a CLI.
\ne.g. \"\$ util folder script\" will look for a script at \$SU_SCRIPTS_PATH/folder/script.(*)
More at https://github.com/vncsmyrnk/shell-utils\n"
    exit 0
  }
}

file_glob_exists_and_is_executable() {
  for script_file in $script_file_glob; do
    if [ -x "$script_file" ]; then
      return 0
    fi
  done
  return 1
}

help_for_file() {
  printf "$(sed -n '/^# \[help\]/,/^$/p' "$1" |
    grep -v '^# \[help\]' |
    sed 's/^# //' |
    sed 's/^#//')"
}

print_help_for_file() {
  help_text=$(help_for_file "$1")
  if [ -n "$help_text" ]; then
    echo "$help_text"
    return 0
  fi

  echo "No help available"
  return 1
}

list_commands_available_glob() {
  help_file_for_current_path="$1/help"
  if [ -f "$help_file_for_current_path" ]; then
    printf "%s" "$(cat "$help_file_for_current_path")"
    printf "\n"
  else
    printf "This command has subcommands, but no help section.\n"
  fi

  printf "\n\033[4mCommands available:\033[0m\n"

  find "$1" \
    -maxdepth 1 \
    -type f \
    -not -iname 'help' \
    -follow |
    while read -r file; do
      command_name=$(basename "$file" | rev | cut -f2- -d "." | rev)
      summarized_help_text=$(help_for_file "$file" | head -n 1)
      printf "\033[1m%s\033[0m" "$command_name"
      if [ -n "$summarized_help_text" ]; then
        printf " - %s" "$summarized_help_text"
      fi
      printf "\n"
    done

  find "$1" \
    -mindepth 1 \
    -maxdepth 1 \
    -type d \
    -follow |
    while read -r dir; do
      command_name=$(basename "$dir")
      printf "\033[1m%s\033[0m\n" "$command_name"
    done
}

help_flag_set() {
  for arg in "$@"; do
    if [ "$arg" = "--help" ]; then
      return 0
    fi
  done
  return 1
}

execute_script() {
  script_path="$1"
  script_arguments="$2"
  sh -c "$script_path $script_arguments"
}

find_and_execute_script() {
  current_path=$(scripts_path)
  for section in "$@"; do
    [ -n "$found_script_file_glob" ] && {
      found_script_arguments="$found_script_arguments \"$section\""
    }

    current_path="$current_path/$section"
    script_file_glob="$current_path.*"
    file_glob_exists_and_is_executable "$script_file_glob" && {
      found_script_file_glob="$script_file_glob"
    }
  done

  if [ -z "$found_script_file_glob" ] && [ -d "$current_path" ]; then
    list_commands_available_glob "$current_path"
    exit 0
  elif [ -z "$found_script_file_glob" ]; then
    return 0
  fi

  script_path=$(find $found_script_file_glob)
  if [ "$(echo "$script_path" | wc -l)" -gt 1 ]; then
    printf "Ambiguity detected. Make sure the scripts at %s have no name conflict.\n" "$(scripts_path)"
    exit 1
  fi

  if help_flag_set "$@"; then
    print_help_for_file "$script_path" || {
      exit 1
    }
    exit 0
  fi

  execute_script "$script_path" "$found_script_arguments"
  exit
}

main() {
  check_dependencies

  check_empty_arguments "$@"
  find_and_execute_script "$@"

  printf "Util file not found. Check \033[1m%s\033[0m for commands available.\n" "$(scripts_path)"
  printf "\033[2mTip: pass file without the extension and make it sure it is executable.\033[0m\n"
  exit 1
}

main "$@"
